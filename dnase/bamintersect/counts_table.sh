#!/bin/bash

set -eu -o pipefail

shopt -s expand_aliases
alias bedops='bedops --ec --header'
alias bedmap='bedmap --ec --header --sweep-all'
#alias starch='starch --header'
alias closest-features='closest-features --header'

#####################################################################################
# counts_table.sh takes a bed12 file as input. This file is generated by bamintersect.py
# The 12 columns are:
#    [chr start end readID flag +/-] x 2, bam1 data being in 1-6, and bam2 data being in 7-12.
# The rows are individual reads.
#
# Lines in the bed12 file are
# aggregated to their nearest genes. Some additional values are calculated, such as quantity of
# reads, widths, and the range of related bam1 reads.
#
# The output file will be named ${OUTBASE}.counts.txt
#
# sampleName is in the form: "<sample_name>.<bam1genome>_vs_<bam2genome>"
#
#####################################################################################

OUTBASE=$1
sample_name=$2
bam1genome=$3
bam2genome=$4
bamintersectBED12=$5

echo "[counts_table] Making counts_table from ${bamintersectBED12}; will output to ${OUTBASE}.counts.txt"


echo -e -n "Number of total reads:\t"
cat ${bamintersectBED12} | wc -l

#Annotate a file by adding a column with the nearest gene name. Inputfile can be stdin (as -); outputs to stdout
function annotateNearestGeneName {
    local inputfile=$1
    local genome=$2
    
    # Set the appropriate gene annotation file.
    # Note that hg38_full, etc. was converted to just "hg38" prior to calling bamintersect.
    local geneAnnotationFile=""
    case "${genome}" in
    mm10)
        geneAnnotationFile=/vol/isg/annotation/bed/mm10/gencodev23/GencodevM23.gene.bed
        ;;
    rn6)
        geneAnnotationFile=/vol/isg/annotation/bed/rn6/ensembl96/Ensemblv96_Rnor.gene.bed
        ;;
    hg38)
        geneAnnotationFile=/vol/isg/annotation/bed/hg38/gencodev31/Gencodev31.gene.bed
        ;;
    *)
        geneAnnotationFile="CEGS"
        ;;
    esac
    
    if [[ "${geneAnnotationFile}" == "CEGS" ]]; then
        cat /vol/cegs/sequences/cegsvectors/cegsvectors/cegsvectors.bed | perl -pe 's/ /_/g;' > $TMPDIR/geneAnnotationFile.${genome}.bed
    else
        #Needs prefiltering
        #Add gene name
        cat ${geneAnnotationFile} |
        awk -F "\t" 'BEGIN {OFS="\t"} $7=="protein_coding"' |
        #Restrict to level 1 or 2 genes if available (Sox2 is level 2 for example)
        awk -F "\t" 'BEGIN {OFS="\t"} $5<=2 || $5=="."' > $TMPDIR/geneAnnotationFile.${genome}.bed
    fi
    geneAnnotationFile="$TMPDIR/geneAnnotationFile.${genome}.bed"
    
    closest-features --delim "|" --closest --dist ${inputfile} ${geneAnnotationFile} |
    #Replace empty gene names with a dash
    #Add distance to the gene name; note distance is relative to the genomic location (+ is to the right) not the transcriptional direction
    awk -F "|" 'BEGIN {OFS="\t"} { \
        split($2, gene, "\t"); if(gene[4]=="") {gene[4]="-"} \
        if($3=="NA" || $3==0) { \
            distance = ""; \
        } else if($3>0) { \
            distance = "-" $3 "bp"; \
        } else { \
            distance = "+" "BUGBUGthisDisappears" -1*$3 "bp"; \
        } \
        print $1, gene[4] distance; \
    }'
}


#Takes a bed file and outputs a list of minimal regions covering all elements grouped by fixed distance to stdout
function merge_tight {
    local file=$1
    local range=$2
    
    #Generate bam1 regions
    cat ${file} | bedops --range ${range} -m - | 
    bedmap --echo-map-range - ${file} |
    #Put the region coordinates into the ID column
    bedmap --delim "\t" --echo --echo-ref-name -
}

#Generate bam1 regions
merge_tight ${bamintersectBED12} 500 > ${TMPDIR}/${sample_name}.regions.bam1.bed

cat ${bamintersectBED12} |
awk -F "\t" 'BEGIN {OFS="\t"}; {print $7, $8, $9, $10, $11, $12, $1, $2, $3, $4, $5, $6}' | sort-bed - > ${TMPDIR}/${sample_name}.reads.bam2.bed

merge_tight ${TMPDIR}/${sample_name}.reads.bam2.bed 500 |
#Annotate each read with the coordinates of the bam2 region it overlaps
bedmap --delim "\t" --echo --echo-map-id ${TMPDIR}/${sample_name}.reads.bam2.bed - |
#Switch the reads annotated with bam2 region back to bam1 (note the extra column $13)
awk -F "\t" 'BEGIN {OFS="\t"}; {print $7, $8, $9, $10, $11, $12, $1, $2, $3, $4, $5, $6, $13}' | sort-bed - |
#Annotate each read with the coordinates of the bam1 region it overlaps
bedmap --delim "\t" --echo --echo-map-id - ${TMPDIR}/${sample_name}.regions.bam1.bed |
#Count reads per unique pairs of bam1/bam2 regions; uses ~ internally as field separator
cut -f13-14 | awk -F "\t" 'BEGIN {OFS="\t"} {counts[$1 "~" $2] += 1} END {for (x in counts) {split(x, countsplit, "~"); print counts[x], countsplit[1], countsplit[2]}}' |
#reorder columns, keep in bam2 coordinates
awk -F "\t" -v minReadsCutoff=2  'BEGIN {OFS="\t"} $1>=minReadsCutoff {split($2, bam2region, /[:-]/); split($3, bam1region, /[:-]/); print bam2region[1], bam2region[2], bam2region[3], bam2region[3]-bam2region[2], $1, bam1region[1], bam1region[2], bam1region[3], bam1region[3]-bam1region[2]}' | sort-bed - |
#Add gene name to bam2
annotateNearestGeneName - ${bam2genome} |
#switch to bam1 coordinates, leaving the bam2 gene name at the end where it belongs
awk -F "\t" 'BEGIN {OFS="\t"} {print $6, $7, $8, $9, $5, $1, $2, $3, $4, $10}' | sort-bed - |
#Add gene name to bam1
annotateNearestGeneName - ${bam1genome} |
#Sort by Reads, chrom_bam2, chromStart_bam2
#tried mlr but it doesn't like the field name below
#mlr --tsv sort -nr Reads -f ${#chrom_bam2} -n chromStart_bam2
sort -k5,5nr -k1,1 -k2,2n |
#Reorder columns to put bam1 gene where it belongs
awk -v short_sample_name=`echo "${sample_name}" | cut -d "." -f1` -F "\t" 'BEGIN {OFS="\t"; print "#chrom_bam1", "chromStart_bam1", "chromEnd_bam1", "Width_bam1", "NearestGene_bam1", "Reads", "chrom_bam2", "chromStart_bam2", "chromEnd_bam2", "Width_bam2", "NearestGene_bam2", "Sample"} {print $1, $2, $3, $4, $11, $5, $6, $7, $8, $9, $10, short_sample_name}' > ${OUTBASE}.counts.txt


#####################################################################################

echo "[counts_table] Done"
date
