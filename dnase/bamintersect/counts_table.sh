#!/bin/bash

set -eu -o pipefail

shopt -s expand_aliases
alias bedops='bedops --ec --header'
alias bedmap='bedmap --ec --header --sweep-all'
#alias starch='starch --header'
alias closest-features='closest-features --header'

#####################################################################################
# counts_table.sh takes a bed12 file as input. This file is generated by bamintersect.py
# The 12 columns are:
#    [chr start end readID flag +/-] x 2, bam1 data being in 1-6, and bam2 data being in 7-12.
# The rows are individual reads.
#
# Lines in the bed12 file are
# aggregated to their nearest genes. Some additional values are calculated, such as quantity of
# reads, widths, and the range of related bam1 reads.
#
# The output file will be named ${OUTBASE}.counts.txt
#
# sampleName is in the form: "<sample_name>.<bam1genome>_vs_<bam2genome>"
#
#####################################################################################

OUTBASE=$1
sample_name=$2
bam2genome=$3
bamintersectBED12=$4

echo "Making counts_table from ${bamintersectBED12}; will output to ${OUTBASE}.counts.txt"


echo -e -n "Number of total reads:\t"
cat ${bamintersectBED12} | wc -l


# Set the appropriate gene annotation file.
# Note that hg38_full, etc. was converted to just "hg38" prior to calling bamintersect.
case "${bam2genome}" in
mm10)
    geneAnnotationFile=/vol/isg/annotation/bed/mm10/gencodev23/GencodevM23.gene.bed
    ;;
rn6)
    geneAnnotationFile=/vol/isg/annotation/bed/rn6/ensembl96/Ensemblv96_Rnor.gene.bed
    ;;
hg38)
    geneAnnotationFile=/vol/isg/annotation/bed/hg38/gencodev31/Gencodev31.gene.bed
    ;;
*)
    echo "ERROR: Don't recognize genome ${bam2genome}";
    exit 1;;
esac


#Takes a bed file and outputs a list of minimal regions covering all elements grouped by fixed distance to stdout
function merge_tight {
    file=$1
    range=$2
    
    #Generate bam1 regions
    cat ${file} | bedops --range ${range} -m - | 
    bedmap --echo-map-range - ${file} |
    #Put the region coordinates into the ID column
    bedmap --delim "\t" --echo --echo-ref-name -
}

#Generate bam1 regions
merge_tight ${bamintersectBED12} 500 > ${TMPDIR}/${sample_name}.regions.bam1.bed

cat ${bamintersectBED12} |
awk -F "\t" 'BEGIN {OFS="\t"}; {print $7, $8, $9, $10, $11, $12, $1, $2, $3, $4, $5, $6}' | sort-bed - > ${TMPDIR}/${sample_name}.reads.bam2.bed

merge_tight ${TMPDIR}/${sample_name}.reads.bam2.bed 5000 |
#Annotate each read with the coordinates of the bam2 region it overlaps
bedmap --delim "\t" --echo --echo-map-id ${TMPDIR}/${sample_name}.reads.bam2.bed - |
#Switch the reads annotated with bam2 region back to bam1 (note the extra column $13)
awk -F "\t" 'BEGIN {OFS="\t"}; {print $7, $8, $9, $10, $11, $12, $1, $2, $3, $4, $5, $6, $13}' | sort-bed - |
#Annotate each read with the coordinates of the bam1 region it overlaps
bedmap --delim "\t" --echo --echo-map-id - ${TMPDIR}/${sample_name}.regions.bam1.bed |
#Count reads per unique pairs of bam1/bam2 regions; uses ~ as field separator
cut -f13-14 | awk -F "\t" 'BEGIN {OFS="\t"} {counts[$1 "~" $2] += 1} END {for (x in counts) {split(x, countsplit, "~"); print counts[x], countsplit[1], countsplit[2]}}' |
#reorder columns
#Keep in bam2 coordinates
awk -F "\t" -v minReadsCutoff=2  'BEGIN {OFS="\t"} $1>=minReadsCutoff {split($2, bam2region, /[:-]/); split($3, bam1region, /[:-]/); print bam2region[1], bam2region[2], bam2region[3], bam2region[3]-bam2region[2], $1, bam1region[1], bam1region[2], bam1region[3], bam1region[3]-bam1region[2]}' | sort-bed - > $TMPDIR/${sample_name}.counts.bed


cat ${geneAnnotationFile} |
awk -F "\t" 'BEGIN {OFS="\t"} $7=="protein_coding"' |
#Restrict to level 1 or 2 genes if available (Sox2 is level 2 for example)
awk -F "\t" 'BEGIN {OFS="\t"} $5<=2 || $5=="."' |
closest-features --delim "|" --closest $TMPDIR/${sample_name}.counts.bed - |
# Replace empty gene names with a dash.
awk -F "|" 'BEGIN {OFS="\t"} {split($2, gene, "\t"); if(gene[4]=="") {gene[4]="-"} print $1, gene[4]}' |
#Sort by Informative_Reads, chrom_bam2, chromStart_bam2
#mlr doesn't like the field name below
#mlr --tsv sort -nr Informative_Reads -f ${#chrom_bam2} -n chromStart_bam2
sort -k5,5nr -k1,1 -k2,2n |
#Reorder columns
awk -v short_sample_name=`echo "${sample_name}" | cut -d "." -f1` -F "\t" 'BEGIN {OFS="\t"; print "#chrom_bam2", "chromStart_bam2", "chromEnd_bam2", "Width_bam2", "NearestGene_bam2", "Informative_Reads", "chrom_bam1", "chromStart_bam1", "chromEnd_bam1", "Width_bam1", "Sample"} {short_sample_name} {print $1, $2, $3, $4, $10, $5, $6, $7, $8, $9, short_sample_name}' > ${OUTBASE}.counts.txt


#####################################################################################

echo "Finished counts_table.sh"
date
